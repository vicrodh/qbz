//! Slint frontend adapter
//!
//! Bridges QBZ Core events to Slint UI updates.

use async_trait::async_trait;
use qbz_core::{CoreEvent, FrontendAdapter};
use slint::{ComponentHandle, Weak};

// Use the App type from main.rs (generated by slint::include_modules!)
use crate::App;

/// Adapter that connects QBZ Core to Slint UI
pub struct SlintAdapter {
    app: Weak<App>,
}

impl SlintAdapter {
    pub fn new(app: &App) -> Self {
        Self {
            app: app.as_weak(),
        }
    }

    /// Update UI from any thread by dispatching to Slint's event loop
    fn update_ui<F>(&self, f: F)
    where
        F: FnOnce(&App) + Send + 'static,
    {
        let app = self.app.clone();
        let _ = slint::invoke_from_event_loop(move || {
            if let Some(app) = app.upgrade() {
                f(&app);
            }
        });
    }
}

#[async_trait]
impl FrontendAdapter for SlintAdapter {
    async fn on_event(&self, event: CoreEvent) {
        match event {
            // ─── Authentication ─────────────────────────────────────
            CoreEvent::LoginRequired => {
                self.update_ui(|app| {
                    app.set_current_view(0); // Login view
                    app.set_is_logged_in(false);
                });
            }

            CoreEvent::LoginSuccess(_user) => {
                self.update_ui(|app| {
                    app.set_current_view(1); // Home view
                    app.set_is_logged_in(true);
                    app.set_is_loading(false);
                });
            }

            CoreEvent::LoginFailed(error) => {
                let error = error.clone();
                self.update_ui(move |app| {
                    app.set_login_error(error.into());
                    app.set_is_loading(false);
                });
            }

            CoreEvent::LoggedOut => {
                self.update_ui(|app| {
                    app.set_current_view(0);
                    app.set_is_logged_in(false);
                });
            }

            // ─── Playback ───────────────────────────────────────────
            CoreEvent::PlaybackStateChanged(state) => {
                self.update_ui(move |app| {
                    app.set_is_playing(state.is_playing);
                    app.set_volume(state.volume);
                    if state.duration > 0 {
                        app.set_position(state.position as f32 / state.duration as f32);
                    }
                });
            }

            CoreEvent::TrackChanged(track) => {
                self.update_ui(move |app| {
                    app.set_current_title(track.title.into());
                    app.set_current_artist(track.artist.into());
                    app.set_current_album(track.album.into());
                });
            }

            CoreEvent::PositionChanged { position, duration } => {
                self.update_ui(move |app| {
                    if duration > 0 {
                        app.set_position(position as f32 / duration as f32);
                    }
                    app.set_position_text(format_time(position).into());
                    app.set_duration_text(format_time(duration).into());
                });
            }

            CoreEvent::VolumeChanged(volume) => {
                self.update_ui(move |app| {
                    app.set_volume(volume);
                });
            }

            CoreEvent::PlaybackStopped => {
                self.update_ui(|app| {
                    app.set_is_playing(false);
                    app.set_position(0.0);
                    app.set_current_title("".into());
                    app.set_current_artist("".into());
                });
            }

            // ─── Queue ──────────────────────────────────────────────
            CoreEvent::QueueChanged(_tracks) => {
                // TODO: Update queue list model
            }

            CoreEvent::QueueIndexChanged(index) => {
                self.update_ui(move |app| {
                    app.set_queue_index(index as i32);
                });
            }

            CoreEvent::ShuffleChanged(shuffle) => {
                self.update_ui(move |app| {
                    app.set_shuffle(shuffle);
                });
            }

            CoreEvent::RepeatChanged(mode) => {
                self.update_ui(move |app| {
                    app.set_repeat_mode(match mode {
                        qbz_core::events::RepeatMode::Off => 0,
                        qbz_core::events::RepeatMode::All => 1,
                        qbz_core::events::RepeatMode::One => 2,
                    });
                });
            }

            // ─── Loading ────────────────────────────────────────────
            CoreEvent::LoadingStarted(_) => {
                self.update_ui(|app| {
                    app.set_is_loading(true);
                });
            }

            CoreEvent::LoadingFinished(_) => {
                self.update_ui(|app| {
                    app.set_is_loading(false);
                });
            }

            CoreEvent::LoadingFailed { error, .. } => {
                log::error!("Loading failed: {}", error);
                self.update_ui(|app| {
                    app.set_is_loading(false);
                });
            }

            // ─── Errors ─────────────────────────────────────────────
            CoreEvent::Error(err) => {
                log::error!("Core error: {} - {}", err.code, err.message);
            }

            CoreEvent::NetworkError(err) => {
                log::error!("Network error: {}", err);
            }

            CoreEvent::AudioError(err) => {
                log::error!("Audio error: {}", err);
            }
        }
    }

    async fn show_notification(&self, title: &str, body: &str) {
        log::info!("Notification: {} - {}", title, body);
        // TODO: Show toast in UI
    }
}

/// Format milliseconds as MM:SS
fn format_time(ms: u64) -> String {
    let total_secs = ms / 1000;
    let mins = total_secs / 60;
    let secs = total_secs % 60;
    format!("{}:{:02}", mins, secs)
}
